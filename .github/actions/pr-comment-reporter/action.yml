name: 'PR Comment Reporter'
description: 'Posts test results and coverage report as PR comment'
inputs:
  github-token:
    description: 'GitHub token for creating PR comments'
    required: true
  test-results-path:
    description: 'Path pattern for test result XML files'
    required: true
    default: '**/build/test-results/test/TEST-*.xml'
  coverage-path:
    description: 'Path pattern for JaCoCo coverage XML files'
    required: true
    default: '**/build/reports/jacoco/test/jacocoTestReport.xml'
  min-coverage:
    description: 'Minimum coverage percentage required'
    required: false
    default: '80'
  comment-tag:
    description: 'Tag to identify PR comments for updates'
    required: false
    default: '<!-- test-coverage-report -->'

runs:
  using: "composite"
  steps:
    - name: Parse test results
      id: test-results
      uses: ./.github/actions/parse-test-results
      with:
        test-results-path: ${{ inputs.test-results-path }}
        fail-on-error: 'false'
    
    - name: Parse coverage
      id: coverage
      uses: ./.github/actions/parse-coverage
      with:
        coverage-path: ${{ inputs.coverage-path }}
        min-coverage: ${{ inputs.min-coverage }}
    
    - name: Create or update PR comment
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const tag = '${{ inputs.comment-tag }}';
          const minCoverage = parseInt('${{ inputs.min-coverage }}');
          
          // Get test results
          const totalTests = parseInt('${{ steps.test-results.outputs.total-tests }}') || 0;
          const passedTests = parseInt('${{ steps.test-results.outputs.passed-tests }}') || 0;
          const failedTests = parseInt('${{ steps.test-results.outputs.failed-tests }}') || 0;
          const errorTests = parseInt('${{ steps.test-results.outputs.error-tests }}') || 0;
          
          // Get coverage
          const coverage = parseFloat('${{ steps.coverage.outputs.overall-coverage }}') || 0;
          const coveragePassed = '${{ steps.coverage.outputs.coverage-passed }}' === 'true';
          
          // Create comment body
          let body = `${tag}\n## 📊 Test Results & Coverage Report\n\n`;
          
          // Test results section
          const testsPassed = failedTests === 0 && errorTests === 0;
          const testIcon = testsPassed ? '✅' : '❌';
          
          body += `### ${testIcon} Tests\n\n`;
          body += `| Status | Count |\n`;
          body += `|--------|-------|\n`;
          body += `| **Total** | ${totalTests} |\n`;
          body += `| ✅ **Passed** | ${passedTests} |\n`;
          if (failedTests > 0) body += `| ❌ **Failed** | ${failedTests} |\n`;
          if (errorTests > 0) body += `| 🚫 **Errors** | ${errorTests} |\n`;
          body += `\n`;
          
          // Coverage section
          const coverageIcon = coveragePassed ? '✅' : '❌';
          const coverageEmoji = coverage >= 90 ? '🏆' : coverage >= 80 ? '✅' : coverage >= 70 ? '⚠️' : '❌';
          
          body += `### ${coverageIcon} Coverage\n\n`;
          body += `| Metric | Value |\n`;
          body += `|--------|-------|\n`;
          body += `| **Overall Coverage** | ${coverageEmoji} ${coverage.toFixed(2)}% |\n`;
          body += `| **Required** | ${minCoverage}% |\n`;
          body += `| **Status** | ${coveragePassed ? '✅ Passed' : '❌ Failed'} |\n`;
          body += `\n`;
          
          // Add summary
          body += `### 📝 Summary\n\n`;
          if (testsPassed && coveragePassed) {
            body += `✅ **All checks passed!** Tests are passing and coverage meets the minimum requirement.\n`;
          } else {
            if (!testsPassed) {
              body += `❌ **Tests failed!** ${failedTests + errorTests} test(s) need attention.\n`;
            }
            if (!coveragePassed) {
              body += `❌ **Coverage too low!** Current coverage (${coverage.toFixed(2)}%) is below the minimum requirement (${minCoverage}%).\n`;
            }
          }
          
          body += `\n---\n`;
          body += `*Generated by PR Test & Coverage workflow* • [View Details](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n`;
          
          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && comment.body.includes(tag)
          );
          
          if (botComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: body
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
          }